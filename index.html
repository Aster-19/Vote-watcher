<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Votes en temps réel</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.3.1/dist/chartjs-plugin-zoom.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #controls, #axis-controls { margin-bottom: 20px; }
    label { margin-right: 10px; }
    h3 { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Votes en temps réel</h1>

  <div id="controls">
    <span>Filtres candidats :</span>
    <div id="candidateCheckboxes"></div>

    <span>Période :</span>
    <select id="timeRange">
      <option value="all">Tout</option>
      <option value="1h">1 heure</option>
      <option value="6h">6 heures</option>
      <option value="24h">24 heures</option>
    </select>
  </div>

  <div id="axis-controls">
    <h3>Configurer les axes</h3>
    <label>Heure début : <input type="datetime-local" id="xStart"></label>
    <label>Heure fin : <input type="datetime-local" id="xEnd"></label>
    <label>Votes min : <input type="number" id="yMin" placeholder="0"></label>
    <label>Votes max : <input type="number" id="yMax" placeholder="max"></label>
    <button id="applyAxes">Appliquer</button>
  </div>

  <canvas id="chart" width="900" height="400"></canvas>

  <script>
    let chart;
    let datasetMap = {};
    let fullHistory = { labels: [], datasets: [] };

    const eventSource = new EventSource("/events");

    function createCandidateCheckbox(name) {
      const container = document.getElementById("candidateCheckboxes");
      const label = document.createElement("label");
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = name;
      cb.checked = true;
      cb.addEventListener("change", updateVisibleCandidates);
      label.appendChild(cb);
      label.appendChild(document.createTextNode(" " + name));
      container.appendChild(label);
    }

    function updateVisibleCandidates() {
      const selected = [...document.querySelectorAll('#candidateCheckboxes input:checked')].map(cb => cb.value);
      chart.data.datasets.forEach(ds => ds.hidden = !selected.includes(ds.label));
      chart.update();
    }

    function filterByTime(range) {
      const now = Date.now();
      const rangesMs = { "1h": 3600000, "6h": 21600000, "24h": 86400000, "all": Infinity };
      const limit = now - rangesMs[range];

      chart.data.labels = fullHistory.labels.filter(t => new Date(t).getTime() >= limit);
      chart.data.datasets.forEach((ds, i) => {
        ds.data = fullHistory.datasets[i].data.filter((_, idx) => new Date(fullHistory.labels[idx]).getTime() >= limit);
      });
      chart.update();
    }

    document.getElementById("timeRange").addEventListener("change", e => filterByTime(e.target.value));

    function applyAxes() {
      const xStart = new Date(document.getElementById("xStart").value).getTime();
      const xEnd   = new Date(document.getElementById("xEnd").value).getTime();
      const yMin   = Number(document.getElementById("yMin").value);
      const yMax   = Number(document.getElementById("yMax").value);

      chart.data.labels = fullHistory.labels.filter(t => {
        const ts = new Date(t).getTime();
        return (!isNaN(xStart) ? ts >= xStart : true) &&
               (!isNaN(xEnd) ? ts <= xEnd : true);
      });

      chart.data.datasets.forEach((ds, i) => {
        ds.data = fullHistory.datasets[i].data.filter((v, idx) => {
          const ts = new Date(fullHistory.labels[idx]).getTime();
          return (!isNaN(xStart) ? ts >= xStart : true) &&
                 (!isNaN(xEnd) ? ts <= xEnd : true);
        });
      });

      chart.options.scales.y.min = !isNaN(yMin) ? yMin : undefined;
      chart.options.scales.y.max = !isNaN(yMax) ? yMax : undefined;

      chart.update();
    }

    document.getElementById("applyAxes").addEventListener("click", applyAxes);

    eventSource.onmessage = (event) => {
      const msg = JSON.parse(event.data);

      if (msg.type === "init") {
        const history = msg.payload;
        if (!history.length) return;

        const labels = history.map(h => h.timestamp);
        const firstSnapshot = history[0].votes;

        for (const name of Object.keys(firstSnapshot)) {
          datasetMap[name] = {
            label: name,
            data: history.map(h => h.votes[name] ?? 0),
            borderWidth: 2,
            fill: false
          };
          createCandidateCheckbox(name);
        }

        fullHistory.labels = [...labels];
        fullHistory.datasets = Object.values(datasetMap).map(ds => ({ ...ds, data: [...ds.data] }));

        const ctx = document.getElementById("chart").getContext("2d");
        chart = new Chart(ctx, {
          type: "line",
          data: { labels: labels, datasets: Object.values(datasetMap) },
          options: {
            responsive: true,
            animation: false,
            scales: { y: { beginAtZero: true } },
            plugins: {
              zoom: {
                zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' },
                pan: { enabled: true, mode: 'x' }
              }
            }
          }
        });
      }

      if (msg.type === "update") {
        const snap = msg.payload;
        chart.data.labels.push(snap.timestamp);

        for (const name of Object.keys(datasetMap)) {
          datasetMap[name].data.push(snap.votes[name] ?? 0);
        }

        fullHistory.labels.push(snap.timestamp);
        Object.keys(datasetMap).forEach((name, i) => {
          fullHistory.datasets[i].data.push(snap.votes[name] ?? 0);
        });

        chart.update();
      }
    };
  </script>
</body>
</html>
